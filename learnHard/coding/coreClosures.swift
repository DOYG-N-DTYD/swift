//
//  coreClosures.swift
//  FirstSwiftProject
//
//  Created by Miroslaw Zborowski on 25/01/2025.
//

// Общий вид замыкания

//{ (параметры) -> тип_возвращаемого_значения in
// 
//    инструкции
//}

let hello = { print("Hello world")}
hello()
hello()
//Фактически константа hello в данном случае имеет тип ()->() или ()-gt;Void:

let hello: ()->Void = { print("Hello world")}
//Дополнительно можно определить список параметров с помощью ключевого слова in:

let hello = {
    (message: String) in
    print(message)
}
hello("Hello")
hello("Salut")
hello("Ni hao")


//Также можно определить возвращаемое значение:
let sum = {
    (x: Int, y: Int) -> Int in
    return x + y
}
print(sum(2, 5))        // 7
print(sum(12, 15))      // 27
print(sum(5, 3))        // 8


//###################################################################################################
//Замыкания как аргументы функций


func operation(_ a: Int, _ b: Int, _ action: (Int, Int) -> Int) -> Int{
     
    return action(a, b)
}
 
let x = 10
let y = 12
let result1 = operation(x, y, {(a: Int, b: Int) -> Int in
     
    return a + b
})
print(result1)    // 22
var result2 = operation(x, y, {(a: Int, b: Int) -> Int in return a - b})
print(result2)    // -2


let x = 10
let y = 12
let result1 = operation(x, y, {(a, b) in a + b })
print(result1)    // 22

let result2 = operation(x, y, {(a, b) in a - b })
print(result2)    // -2


let x = 10
let y = 12
 
let result1 = operation(x, y, {$0 + $1}) // $0 первый параметр переданный в функцию $2 второй параметр !
print(result1)    // 22
 
let result2 = operation(x, y, {$0 - $1})
print(result2)    // -2

let x = 10
let y = 12
 
let result1 = operation(x, y, +)
print(result1)    // 22
 
let result2 = operation(x, y, -)
print(result2)    // -2

//###################################################################################################
//Доступ к контексту

//Замыкания имеют полный доступ к контексту, в котором они определены. Кроме того, замыкания могут использовать внешние переменные и константы как состояние, которое может храниться на всем протяжении жизни замыкания:

func action() -> (()->Int){
     
    var val = 0
    return {
        val = val+1
        return val
    }
}
let inc = action()
print(inc())    // 1
print(inc())    // 2
//Здесь определена функция action, которая, в свою очередь, сама возвращает функцию. По факту она возвращает замыкающее выражение, которое увеличивает внешнюю переменную val на единицу и затем возвращает ее значение. Но при вызове мы видим, что переменная val сохраняет свое значение после увеличения, оно не сбрасывается обратно к нулю при каждом вызове функции. То есть переменная val представляет состояние, где замыкание может хранить данные.


//###################################################################################################
//Захват значений
//Замыкающие выражения обладают способностью сохранять начальные значения переданных в них переменных. Например, рассмотрим следующую ситуацию:

var a = 14
var b = 2
 
let myClosure: () -> Int = {return a + b}
print(myClosure())  // 16
 
a = 5
b = 6
print(myClosure())  // 11
//Замыкающее выражение, на которое указывает константа myClosure, складывает значения переменных a и b. С изменением значений переменных также меняется результат замыкания myClosure. Однако мы можем зафиксировать начальные значения переменных:

var a = 14
var b = 2
 
let myClosure: () -> Int = {[a, b] in return a + b}
print(myClosure())  // 16
 
a = 5
b = 6
print(myClosure())  // 16
//Передав переменные в квадратные скобки: [a, b], мы тем самым фиксируем их начальные значения. И даже если значения этих переменных в какой-то момент изменятся, замыкание будет оперировать прежними значениями.
